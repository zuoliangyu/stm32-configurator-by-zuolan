/*---------------------------------------------------------------------------------------------
 * Copyright (c) 2025 左岚. All rights reserved.
 * Licensed under the MIT License. See LICENSE file in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * UI组件功能测试
 * 测试工具链引导对话框的各个UI处理器组件
 * 
 * @fileoverview UI组件测试套件
 * @author 左岚
 * @since 0.2.5
 */

import * as assert from 'assert';
import * as sinon from 'sinon';
import * as vscode from 'vscode';
import { DetectionProgressHandler } from '../ui/detectionProgressHandler';
import { ResultDisplayHandler } from '../ui/resultDisplayHandler';
import { UserInteractionHandler } from '../ui/userInteractionHandler';
import { ConfigurationHandler } from '../ui/configurationHandler';
import { LocalizationManager } from '../localization/localizationManager';
import { UserAction, DetectionStatus } from '../ui/types';

describe('UI Components Tests', () => {
    let sandbox: sinon.SinonSandbox;
    let mockLocalizationManager: LocalizationManager;
    let mockContext: vscode.ExtensionContext;

    beforeEach(() => {
        sandbox = sinon.createSandbox();
        
        // Mock ExtensionContext
        mockContext = {
            subscriptions: [],
            workspaceState: { get: sandbox.stub(), update: sandbox.stub(), keys: sandbox.stub() },
            globalState: { 
                get: sandbox.stub(), 
                update: sandbox.stub(), 
                keys: sandbox.stub(), 
                setKeysForSync: sandbox.stub() 
            },
            secrets: {
                get: sandbox.stub(),
                store: sandbox.stub(),
                delete: sandbox.stub(),
                onDidChange: sandbox.stub()
            },
            extensionUri: vscode.Uri.file('/test'),
            extensionPath: '/test',
            environmentVariableCollection: {} as any,
            storagePath: '/test/storage',
            globalStoragePath: '/test/global',
            logPath: '/test/logs',
            extensionMode: vscode.ExtensionMode.Test,
            extension: {} as any,
            logUri: vscode.Uri.file('/test/logs'),
            storageUri: vscode.Uri.file('/test/storage'),
            globalStorageUri: vscode.Uri.file('/test/global')
        } as any;

        // Mock LocalizationManager
        mockLocalizationManager = {
            getString: sandbox.stub().callsFake((key: string) => {
                const strings: { [key: string]: string } = {
                    'toolchainDetectionTitle': 'Toolchain Detection',
                    'detectingToolchains': 'Detecting toolchains...',
                    'toolchainDetectionComplete': 'Detection complete',
                    'openocd': 'OpenOCD',
                    'armToolchain': 'ARM Toolchain',
                    'found': 'Found',
                    'notFound': 'Not Found',
                    'continue': 'Continue',
                    'cancel': 'Cancel',
                    'configureManually': 'Configure Manually',
                    'downloadLinks': 'Download Links',
                    'browseForPath': 'Browse for Path',
                    'toolchainSetupSuccess': 'Toolchain setup completed successfully!'
                };
                return strings[key] || key;
            }),
            getCurrentLanguage: sandbox.stub().returns('en'),
            switchLanguage: sandbox.stub(),
            getAllStrings: sandbox.stub().returns({}),
            formatString: sandbox.stub().callsFake((template: string, ...args: string[]) => {
                return template.replace(/{(\d+)}/g, (match, index) => args[index] || match);
            })
        } as any;
    });

    afterEach(() => {
        sandbox.restore();
    });

    describe('DetectionProgressHandler Tests', () => {
        let progressHandler: DetectionProgressHandler;

        beforeEach(() => {
            progressHandler = new DetectionProgressHandler(mockLocalizationManager);
        });

        it('should create DetectionProgressHandler successfully', () => {
            assert.ok(progressHandler);
            assert.strictEqual(typeof progressHandler.executeDetection, 'function');
        });

        it('should execute detection with progress dialog', async () => {
            // Mock VS Code progress dialog
            const mockProgress = {
                report: sandbox.stub()
            };

            const withProgressStub = sandbox.stub(vscode.window, 'withProgress')
                .callsFake(async (options, task) => {
                    assert.strictEqual(options.location, vscode.ProgressLocation.Notification);
                    assert.ok(options.title.includes('Detection'));
                    
                    return await task(mockProgress as any, {} as any);
                });

            // Mock ToolchainDetectionService
            const mockResults = {
                openocd: { name: 'OpenOCD', status: 'found' as const, path: '/test', detectedAt: Date.now() },
                armToolchain: { name: 'ARM GCC', status: 'found' as const, path: '/test', detectedAt: Date.now() },
                completedAt: Date.now()
            };

            // We need to mock the service import
            const mockService = {
                getInstance: sandbox.stub().returns({
                    detectToolchains: sandbox.stub().resolves(mockResults)
                })
            };

            const results = await progressHandler.executeDetection();

            assert.ok(withProgressStub.calledOnce);
        });

        it('should handle detection errors in progress dialog', async () => {
            // Mock progress dialog that throws error
            sandbox.stub(vscode.window, 'withProgress')
                .callsFake(async (options: any, task: any) => {
                    throw new Error('Detection service failed');
                });

            try {
                await progressHandler.executeDetection();
                assert.fail('Should have thrown error');
            } catch (error) {
                assert.ok(error instanceof Error);
                assert.strictEqual(error.message, 'Detection service failed');
            }
        });

        it('should report progress updates during detection', async () => {
            const reportStub = sandbox.stub();
            const mockProgress = { report: reportStub };

            sandbox.stub(vscode.window, 'withProgress')
                .callsFake(async (options: any, task: any) => {
                    return await task(mockProgress as any, {} as any);
                });

            await progressHandler.executeDetection();

            // Progress should be reported during detection
            assert.ok(reportStub.called);
        });
    });

    describe('ResultDisplayHandler Tests', () => {
        let displayHandler: ResultDisplayHandler;

        beforeEach(() => {
            displayHandler = new ResultDisplayHandler(mockLocalizationManager);
        });

        it('should create ResultDisplayHandler successfully', () => {
            assert.ok(displayHandler);
            assert.strictEqual(typeof displayHandler.showResultsDialog, 'function');
        });

        it('should show results dialog for successful detection', async () => {
            const mockResults = {
                openocd: { 
                    name: 'OpenOCD', 
                    status: DetectionStatus.SUCCESS, 
                    path: '/usr/bin/openocd',
                    info: 'OpenOCD 0.12.0'
                },
                armToolchain: { 
                    name: 'ARM GCC', 
                    status: DetectionStatus.SUCCESS, 
                    path: '/usr/bin/arm-none-eabi-gcc',
                    info: 'GCC 12.2.0'
                }
            };

            // Mock user selecting Continue
            const showInformationMessageStub = sandbox.stub(vscode.window, 'showInformationMessage')
                .resolves('Continue' as any);

            const result = await displayHandler.showResultsDialog(mockResults);

            assert.ok(showInformationMessageStub.called);
            assert.strictEqual(result, UserAction.CONTINUE);
        });

        it('should show results dialog for failed detection', async () => {
            const mockResults = {
                openocd: { 
                    name: 'OpenOCD', 
                    status: DetectionStatus.FAILED, 
                    path: null,
                    error: 'OpenOCD not found in PATH'
                },
                armToolchain: { 
                    name: 'ARM GCC', 
                    status: DetectionStatus.FAILED, 
                    path: null,
                    error: 'ARM toolchain not found'
                }
            };

            // Mock user selecting Configure Manually
            const showInformationMessageStub = sandbox.stub(vscode.window, 'showInformationMessage')
                .resolves('Configure Manually' as any);

            const result = await displayHandler.showResultsDialog(mockResults);

            assert.ok(showInformationMessageStub.called);
            assert.strictEqual(result, UserAction.CONFIGURE_MANUALLY);
        });

        it('should handle user cancellation in results dialog', async () => {
            const mockResults = {
                openocd: { name: 'OpenOCD', status: 'found' as const, path: '/test' },
                armToolchain: { name: 'ARM GCC', status: 'found' as const, path: '/test' }
            };

            // Mock user cancelling (undefined return)
            sandbox.stub(vscode.window, 'showInformationMessage').resolves(undefined);

            const result = await displayHandler.showResultsDialog(mockResults);

            assert.strictEqual(result, UserAction.CANCEL);
        });

        it('should format detection results correctly', async () => {
            const mockResults = {
                openocd: { 
                    name: 'OpenOCD', 
                    status: DetectionStatus.SUCCESS, 
                    path: '/usr/bin/openocd',
                    info: 'OpenOCD 0.12.0'
                },
                armToolchain: { 
                    name: 'ARM GCC', 
                    status: DetectionStatus.FAILED, 
                    path: null,
                    error: 'Permission denied'
                }
            };

            const showMessageStub = sandbox.stub(vscode.window, 'showInformationMessage')
                .resolves('Continue' as any);

            await displayHandler.showResultsDialog(mockResults);

            // Check that message contains formatted results
            const messageArg = showMessageStub.firstCall.args[0];
            assert.ok(typeof messageArg === 'string');
            assert.ok(messageArg.includes('OpenOCD'));
            assert.ok(messageArg.includes('ARM'));
        });
    });

    describe('UserInteractionHandler Tests', () => {
        let interactionHandler: UserInteractionHandler;

        beforeEach(() => {
            interactionHandler = new UserInteractionHandler(mockLocalizationManager);
        });

        it('should create UserInteractionHandler successfully', () => {
            assert.ok(interactionHandler);
            assert.strictEqual(typeof interactionHandler.handleManualConfiguration, 'function');
            assert.strictEqual(typeof interactionHandler.handleDownloadLinks, 'function');
        });

        it('should handle manual path configuration', async () => {
            // Mock file selection dialog
            const testPath = '/custom/path/openocd';
            sandbox.stub(vscode.window, 'showOpenDialog').resolves([
                vscode.Uri.file(testPath)
            ]);

            const result = await interactionHandler.handleManualConfiguration('openocd');

            assert.strictEqual(result, testPath);
        });

        it('should handle cancelled manual configuration', async () => {
            // Mock user cancelling file dialog
            sandbox.stub(vscode.window, 'showOpenDialog').resolves(undefined);

            const result = await interactionHandler.handleManualConfiguration('openocd');

            assert.strictEqual(result, null);
        });

        it('should validate selected file path', async () => {
            // Mock selecting file that doesn't look like OpenOCD
            sandbox.stub(vscode.window, 'showOpenDialog').resolves([
                vscode.Uri.file('/some/random/file.txt')
            ]);

            // Mock user confirming to use anyway
            sandbox.stub(vscode.window, 'showWarningMessage')
                .resolves('Yes' as any);

            const result = await interactionHandler.handleManualConfiguration('openocd');

            assert.strictEqual(result, '/some/random/file.txt');
        });

        it('should reject invalid file after user confirmation', async () => {
            // Mock selecting invalid file
            sandbox.stub(vscode.window, 'showOpenDialog').resolves([
                vscode.Uri.file('/some/random/file.txt')
            ]);

            // Mock user rejecting to use file
            sandbox.stub(vscode.window, 'showWarningMessage')
                .resolves('No' as any);

            const result = await interactionHandler.handleManualConfiguration('openocd');

            assert.strictEqual(result, null);
        });

        it('should open download links', async () => {
            // Mock VS Code env.openExternal
            const openExternalStub = sandbox.stub(vscode.env, 'openExternal').resolves(true);

            await interactionHandler.handleDownloadLinks();

            // Should open at least one download link
            assert.ok(openExternalStub.called);
        });

        it('should handle download link errors gracefully', async () => {
            // Mock openExternal to fail
            sandbox.stub(vscode.env, 'openExternal').rejects(new Error('Failed to open link'));

            // Mock error message display
            const showErrorStub = sandbox.stub(vscode.window, 'showErrorMessage');

            await interactionHandler.handleDownloadLinks();

            // Should handle error gracefully
            assert.ok(showErrorStub.called);
        });
    });

    describe('ConfigurationHandler Tests', () => {
        let configHandler: ConfigurationHandler;

        beforeEach(() => {
            configHandler = new ConfigurationHandler(mockLocalizationManager);
        });

        it('should create ConfigurationHandler successfully', () => {
            assert.ok(configHandler);
            assert.strictEqual(typeof configHandler.saveToolchainConfiguration, 'function');
            assert.strictEqual(typeof configHandler.getFailedToolchains, 'function');
        });

        it('should save toolchain configuration successfully', async () => {
            const mockResults = {
                openocd: { 
                    name: 'OpenOCD', 
                    status: DetectionStatus.SUCCESS, 
                    path: 'C:\\Program Files\\OpenOCD\\bin\\openocd.exe'
                },
                armToolchain: { 
                    name: 'ARM GCC', 
                    status: DetectionStatus.SUCCESS, 
                    path: 'C:\\Program Files\\ARM\\bin\\arm-none-eabi-gcc.exe'
                }
            };

            // Mock VS Code configuration
            const updateStub = sandbox.stub().resolves();
            sandbox.stub(vscode.workspace, 'getConfiguration').returns({
                update: updateStub
            } as any);

            await configHandler.saveToolchainConfiguration(mockResults);

            // Should save both paths with forward slashes
            assert.ok(updateStub.calledTwice);
            
            // Check that paths are normalized to forward slashes
            const openocdCall = updateStub.getCalls().find(call => 
                call.args[0] === 'openocdPath'
            );
            assert.ok(openocdCall);
            assert.ok(openocdCall.args[1].includes('/'));
            assert.ok(!openocdCall.args[1].includes('\\'));
        });

        it('should handle configuration save errors', async () => {
            const mockResults = {
                openocd: { name: 'OpenOCD', status: 'found' as const, path: '/test' },
                armToolchain: { name: 'ARM GCC', status: 'found' as const, path: '/test' }
            };

            // Mock configuration update to fail
            const updateStub = sandbox.stub().rejects(new Error('Config save failed'));
            sandbox.stub(vscode.workspace, 'getConfiguration').returns({
                update: updateStub
            } as any);

            try {
                await configHandler.saveToolchainConfiguration(mockResults);
                assert.fail('Should have thrown error');
            } catch (error) {
                assert.ok(error instanceof Error);
                assert.strictEqual(error.message, 'Config save failed');
            }
        });

        it('should identify failed toolchains correctly', () => {
            const mockResults = {
                openocd: { name: 'OpenOCD', status: 'not_found' as const, path: null },
                armToolchain: { name: 'ARM GCC', status: 'found' as const, path: '/test' }
            };

            const failedToolchains = configHandler.getFailedToolchains(mockResults);

            assert.strictEqual(failedToolchains.length, 1);
            assert.strictEqual(failedToolchains[0], 'openocd');
        });

        it('should update toolchain path in results', () => {
            const mockResults = {
                openocd: { name: 'OpenOCD', status: 'not_found' as const, path: null },
                armToolchain: { name: 'ARM GCC', status: 'found' as const, path: '/test' }
            };

            const newPath = '/custom/openocd/path';
            configHandler.updateToolchainPath(mockResults, 'openocd', newPath);

            assert.strictEqual(mockResults.openocd.path, newPath);
            assert.strictEqual(mockResults.openocd.status, 'found');
        });

        it('should skip saving configuration for tools not found', async () => {
            const mockResults = {
                openocd: { name: 'OpenOCD', status: 'not_found' as const, path: null },
                armToolchain: { name: 'ARM GCC', status: 'not_found' as const, path: null }
            };

            const updateStub = sandbox.stub().resolves();
            sandbox.stub(vscode.workspace, 'getConfiguration').returns({
                update: updateStub
            } as any);

            await configHandler.saveToolchainConfiguration(mockResults);

            // Should not attempt to save any configuration
            assert.ok(updateStub.notCalled);
        });
    });
});