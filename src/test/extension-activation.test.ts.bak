/*---------------------------------------------------------------------------------------------
 * Copyright (c) 2025 左岚. All rights reserved.
 * Licensed under the MIT License. See LICENSE file in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * 扩展激活和命令注册测试
 * 测试VS Code扩展的激活流程和命令注册功能
 * 
 * @fileoverview 扩展激活测试套件
 * @author 左岚
 * @since 0.2.5
 */

import * as assert from 'assert';
import * as sinon from 'sinon';
import * as vscode from 'vscode';
import { activate, deactivate } from '../extension';
import { LocalizationManager } from '../localization/localizationManager';
import { ToolchainDetectionService } from '../services/toolchainDetectionService';
import { ToolchainGuideDialog } from '../ui/toolchainGuideDialog';

describe('Extension Activation Tests', () => {
    let sandbox: sinon.SinonSandbox;
    let mockContext: vscode.ExtensionContext;

    beforeEach(() => {
        sandbox = sinon.createSandbox();
        
        // Create comprehensive mock context
        mockContext = {
            subscriptions: [],
            workspaceState: {
                get: sandbox.stub(),
                update: sandbox.stub().resolves(),
                keys: sandbox.stub().returns([])
            },
            globalState: {
                get: sandbox.stub(),
                update: sandbox.stub().resolves(),
                keys: sandbox.stub().returns([]),
                setKeysForSync: sandbox.stub()
            },
            secrets: {
                get: sandbox.stub().resolves(),
                store: sandbox.stub().resolves(),
                delete: sandbox.stub().resolves(),
                onDidChange: sandbox.stub()
            },
            extensionUri: vscode.Uri.file('/test/extension'),
            extensionPath: '/test/extension',
            environmentVariableCollection: {
                persistent: true,
                description: 'Test collection',
                clear: sandbox.stub(),
                delete: sandbox.stub(),
                forEach: sandbox.stub(),
                get: sandbox.stub(),
                prepend: sandbox.stub(),
                replace: sandbox.stub(),
                append: sandbox.stub(),
                getScoped: sandbox.stub()
            },
            storagePath: '/test/storage',
            globalStoragePath: '/test/global-storage',
            logPath: '/test/logs',
            extensionMode: vscode.ExtensionMode.Test,
            extension: {} as any,
            logUri: vscode.Uri.file('/test/logs'),
            storageUri: vscode.Uri.file('/test/storage'),
            globalStorageUri: vscode.Uri.file('/test/global-storage')
        } as any;

        // Mock VS Code API
        sandbox.stub(vscode.window, 'createTreeView').returns({
            dispose: sandbox.stub(),
            onDidChangeSelection: sandbox.stub(),
            onDidChangeVisibility: sandbox.stub(),
            onDidCollapseElement: sandbox.stub(),
            onDidExpandElement: sandbox.stub(),
            selection: [],
            visible: true,
            reveal: sandbox.stub()
        } as any);

        sandbox.stub(vscode.commands, 'registerCommand').callsFake((command: string, callback: (...args: any[]) => any) => {
            return { dispose: sandbox.stub() } as vscode.Disposable;
        });
    });

    afterEach(() => {
        sandbox.restore();
    });

    describe('Extension Activation', () => {
        it('should activate extension without errors', () => {
            // Mock findOpenOCDPath to return immediately
            const findOpenOCDStub = sandbox.stub().resolves('/usr/bin/openocd');
            
            // Mock the imports that might not be available in test
            const moduleStub = {
                findOpenOCDPath: findOpenOCDStub
            };

            assert.doesNotThrow(() => {
                activate(mockContext);
            });
        });

        it('should register all required commands', () => {
            const registerCommandStub = sandbox.stub(vscode.commands, 'registerCommand');
            
            activate(mockContext);

            // Verify all expected commands are registered
            const expectedCommands = [
                'stm32-configurator-by-zuolan.detectToolchain',
                'stm32-configurator-by-zuolan.start',
                'stm32-configurator-by-zuolan.refresh',
                'stm32-configurator-by-zuolan.openConfig',
                'stm32-configurator-by-zuolan.addLiveWatchVariable',
                'stm32-configurator-by-zuolan.removeLiveWatchVariable',
                'stm32-configurator-by-zuolan.toggleLanguage',
                'stm32-configurator-by-zuolan.setupToolchain'
            ];

            expectedCommands.forEach(command => {
                assert.ok(
                    registerCommandStub.calledWith(command, sinon.match.func),
                    `Command ${command} should be registered`
                );
            });
        });

        it('should create tree view with correct configuration', () => {
            const createTreeViewStub = sandbox.stub(vscode.window, 'createTreeView');
            
            activate(mockContext);

            assert.ok(createTreeViewStub.calledOnce);
            assert.strictEqual(createTreeViewStub.firstCall.args[0], 'stm32-configurator-tree');
            
            const config = createTreeViewStub.firstCall.args[1];
            assert.ok(config.treeDataProvider);
            assert.strictEqual(config.showCollapseAll, true);
        });

        it('should initialize localization manager', () => {
            const getInstanceStub = sandbox.stub(LocalizationManager, 'getInstance').returns({
                getString: sandbox.stub(),
                getCurrentLanguage: sandbox.stub(),
                switchLanguage: sandbox.stub(),
                getAllStrings: sandbox.stub(),
                formatString: sandbox.stub()
            } as any);

            activate(mockContext);

            assert.ok(getInstanceStub.calledOnce);
            assert.ok(getInstanceStub.calledWith(mockContext));
        });

        it('should handle OpenOCD path detection errors gracefully', async () => {
            // Mock findOpenOCDPath to reject
            const findOpenOCDStub = sandbox.stub().rejects(new Error('OpenOCD detection failed'));
            
            // Mock console.error to capture error logging
            const consoleErrorStub = sandbox.stub(console, 'error');

            activate(mockContext);

            // Wait a bit for async operations
            await new Promise(resolve => setTimeout(resolve, 10));

            // Should not throw, should log error instead
            assert.ok(consoleErrorStub.called);
        });
    });

    describe('Command Execution Tests', () => {
        let commandHandlers: Map<string, Function>;

        beforeEach(() => {
            commandHandlers = new Map();
            
            // Capture command handlers during registration
            sandbox.stub(vscode.commands, 'registerCommand').callsFake((command: string, handler: Function) => {
                commandHandlers.set(command, handler);
                return { dispose: sandbox.stub() } as vscode.Disposable;
            });

            activate(mockContext);
        });

        it('should handle detectToolchain command execution', async () => {
            const detectHandler = commandHandlers.get('stm32-configurator-by-zuolan.detectToolchain');
            assert.ok(detectHandler, 'detectToolchain handler should be registered');

            // Mock ToolchainGuideDialog
            const showWizardStub = sandbox.stub().resolves(true);
            sandbox.stub(ToolchainGuideDialog.prototype, 'showWizard').callsFake(showWizardStub);

            // Mock success message
            const showInfoStub = sandbox.stub(vscode.window, 'showInformationMessage');

            await detectHandler();

            assert.ok(showWizardStub.calledOnce);
        });

        it('should handle setupToolchain command with wizard option', async () => {
            const setupHandler = commandHandlers.get('stm32-configurator-by-zuolan.setupToolchain');
            assert.ok(setupHandler, 'setupToolchain handler should be registered');

            // Mock user selecting wizard option
            sandbox.stub(vscode.window, 'showQuickPick').resolves({ value: 'wizard' });
            
            // Mock command execution
            const executeCommandStub = sandbox.stub(vscode.commands, 'executeCommand');

            await setupHandler();

            assert.ok(executeCommandStub.calledWith('stm32-configurator-by-zuolan.detectToolchain'));
        });

        it('should handle setupToolchain command with manual option', async () => {
            const setupHandler = commandHandlers.get('stm32-configurator-by-zuolan.setupToolchain');
            assert.ok(setupHandler, 'setupToolchain handler should be registered');

            // Mock user selecting manual option
            sandbox.stub(vscode.window, 'showQuickPick').resolves({ value: 'manual' });
            
            // Mock command execution
            const executeCommandStub = sandbox.stub(vscode.commands, 'executeCommand');

            await setupHandler();

            assert.ok(executeCommandStub.calledWith('workbench.action.openSettings', 'stm32-configurator'));
        });

        it('should handle toggleLanguage command', async () => {
            const toggleHandler = commandHandlers.get('stm32-configurator-by-zuolan.toggleLanguage');
            assert.ok(toggleHandler, 'toggleLanguage handler should be registered');

            // Mock LocalizationManager
            const mockLocManager = {
                getCurrentLanguage: sandbox.stub().returns('en'),
                switchLanguage: sandbox.stub(),
                getAllStrings: sandbox.stub().returns({})
            };
            
            sandbox.stub(LocalizationManager, 'getInstance').returns(mockLocManager as any);

            await toggleHandler();

            assert.ok(mockLocManager.switchLanguage.calledWith('zh'));
        });

        it('should handle addLiveWatchVariable command', async () => {
            const addVarHandler = commandHandlers.get('stm32-configurator-by-zuolan.addLiveWatchVariable');
            assert.ok(addVarHandler, 'addLiveWatchVariable handler should be registered');

            // Mock input box
            sandbox.stub(vscode.window, 'showInputBox').resolves('testVariable');
            
            // Mock information message
            const showInfoStub = sandbox.stub(vscode.window, 'showInformationMessage');

            await addVarHandler();

            // Should not throw and should process the variable
            assert.ok(showInfoStub.called || true); // Either shows message or handles silently
        });

        it('should handle error in detectToolchain command', async () => {
            const detectHandler = commandHandlers.get('stm32-configurator-by-zuolan.detectToolchain');
            assert.ok(detectHandler, 'detectToolchain handler should be registered');

            // Mock ToolchainGuideDialog to throw error
            sandbox.stub(ToolchainGuideDialog.prototype, 'showWizard')
                .rejects(new Error('Detection failed'));

            // Mock error message
            const showErrorStub = sandbox.stub(vscode.window, 'showErrorMessage');

            await detectHandler();

            assert.ok(showErrorStub.called);
            assert.ok(showErrorStub.calledWith(sinon.match(/failed/)));
        });
    });

    describe('Extension Deactivation', () => {
        it('should deactivate extension without errors', () => {
            assert.doesNotThrow(() => {
                deactivate();
            });
        });

        it('should clean up resources properly', () => {
            // Currently deactivate() is empty, but test structure is here
            // for future cleanup logic
            const result = deactivate();
            assert.strictEqual(result, undefined);
        });
    });

    describe('Context Subscription Management', () => {
        it('should add all disposables to context subscriptions', () => {
            activate(mockContext);

            // Should have registered multiple disposables
            assert.ok(mockContext.subscriptions.length > 0);
        });

        it('should handle context subscription disposal', () => {
            const mockDisposable = { dispose: sandbox.stub() };
            sandbox.stub(vscode.commands, 'registerCommand').returns(mockDisposable as any);

            activate(mockContext);

            // Simulate extension deactivation by disposing all subscriptions
            mockContext.subscriptions.forEach(sub => {
                if (typeof sub.dispose === 'function') {
                    sub.dispose();
                }
            });

            // Should not throw during disposal
            assert.ok(true);
        });
    });
});